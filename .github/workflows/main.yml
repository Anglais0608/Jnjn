# .github/workflows/android-emulator-vnc.yml
name: Android Emulator with UI & Remote Access

# Allows manual triggering from the GitHub Actions UI
on:
  workflow_dispatch:

jobs:
  emulate-and-connect:
    runs-on: ubuntu-latest
    # Increase timeout if needed (default is 360 minutes / 6 hours for the job)
    # timeout-minutes: 60 

    steps:
      - name: Checkout code (optional)
        uses: actions/checkout@v4

      - name: Check KVM availability & Enable
        id: kvm_check
        run: |
          echo "Checking KVM..."
          sudo apt-get update -y
          sudo apt-get install -y cpu-checker qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils
          if sudo kvm-ok; then
            echo "KVM acceleration can be used."
            echo "Adding user to kvm group..."
            sudo adduser $USER kvm
            # Note: Group changes usually take effect in GH Actions runners without logout/login.
            echo "kvm_enabled=true" >> $GITHUB_OUTPUT
          else
            echo "WARNING: KVM acceleration not available or disabled. Emulation will be VERY slow."
            echo "kvm_enabled=false" >> $GITHUB_OUTPUT
          fi
          echo "KVM setup check complete."


      - name: Install Dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends \
            openjdk-17-jdk \
            wget \
            unzip \
            xvfb \
            x11vnc \
            adb \
            tmate
          # Clean up apt cache
          sudo rm -rf /var/lib/apt/lists/*

      - name: Set up Android SDK
        env:
          # --- Customize These ---
          API_LEVEL: 31         # e.g., 30 (Android 11), 31 (Android 12), 33 (Android 13)
          TARGET: google_apis   # google_apis includes Google Play services (use default for non-Google API image)
          ARCH: x86_64          # x86_64 is usually fastest in emulation
          AVD_NAME: test_avd
          # --- --- ----------- ---
          CMDLINE_TOOLS_VERSION: "11076708" # Check for latest: https://developer.android.com/studio#command-tools
        run: |
          echo "Setting up environment variables..."
          echo "ANDROID_SDK_ROOT=${HOME}/android-sdk" >> $GITHUB_ENV
          # Add SDK paths persistently for subsequent steps
          echo "${HOME}/android-sdk/cmdline-tools/latest/bin" >> $GITHUB_PATH
          echo "${HOME}/android-sdk/platform-tools" >> $GITHUB_PATH
          echo "${HOME}/android-sdk/emulator" >> $GITHUB_PATH
          # Export for the current step
          export ANDROID_SDK_ROOT="${HOME}/android-sdk"
          export PATH="$PATH:${ANDROID_SDK_ROOT}/cmdline-tools/latest/bin:${ANDROID_SDK_ROOT}/platform-tools:${ANDROID_SDK_ROOT}/emulator"

          echo "Downloading Android Command-line tools..."
          CMDLINE_TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-${CMDLINE_TOOLS_VERSION}_latest.zip"
          mkdir -p "${ANDROID_SDK_ROOT}/cmdline-tools"
          wget -q "${CMDLINE_TOOLS_URL}" -O /tmp/cmdline-tools.zip
          unzip -q /tmp/cmdline-tools.zip -d "${ANDROID_SDK_ROOT}/cmdline-tools"
          # The tools unzip into a 'cmdline-tools' dir, we want them in 'latest'
          mv "${ANDROID_SDK_ROOT}/cmdline-tools/cmdline-tools" "${ANDROID_SDK_ROOT}/cmdline-tools/latest"
          rm /tmp/cmdline-tools.zip

          echo "Accepting licenses..."
          yes | sdkmanager --licenses > /dev/null || true # Ignore errors from already accepted licenses
          # Accept licenses again for packages that might not be installed yet
          yes | sdkmanager --licenses --sdk_root="$ANDROID_SDK_ROOT" > /dev/null || true

          echo "Installing SDK packages..."
          sdkmanager "platform-tools" "emulator" "system-images;android-${API_LEVEL};${TARGET};${ARCH}"

          echo "Creating AVD..."
          # Using a default device profile like pixel_5 might give better compatibility
          echo "no" | avdmanager create avd -n "${AVD_NAME}" -k "system-images;android-${API_LEVEL};${TARGET};${ARCH}" --device "pixel_5" --force

          echo "AVD details:"
          avdmanager list avd

      - name: Start Virtual Display (Xvfb)
        run: |
          echo "Starting Xvfb..."
          Xvfb :99 -screen 0 1280x800x24 &
          echo "DISPLAY=:99" >> $GITHUB_ENV
          sleep 3 # Give Xvfb a moment to start

      - name: Start Android Emulator
        env:
          AVD_NAME: test_avd # Must match the name used in setup step
          DISPLAY: :99       # Must match Xvfb display
        run: |
          echo "Starting emulator..."
          # Use software rendering (swiftshader_indirect) for reliability in CI
          # KVM accelerates CPU execution if enabled, but GPU rendering is software.
          emulator -avd "${AVD_NAME}" \
                   -no-snapshot \
                   -no-boot-anim \
                   -no-audio \
                   -gpu swiftshader_indirect &

          echo "Waiting for ADB device..."
          adb wait-for-device shell exit # Wait until adb shell command can succeed

          echo "Waiting for emulator to fully boot..."
          adb shell 'while [[ -z $(getprop sys.boot_completed) ]]; do sleep 5; echo "Waiting for boot..."; done'
          sleep 2 # Short wait after boot completed signal
          adb shell input keyevent 82 # Unlock screen (KEYCODE_MENU) often works

          echo "Emulator is ready."
          adb devices

      - name: Setup VNC Server
        env:
          DISPLAY: :99 # Must match Xvfb display
          # VNC_PASSWORD: ghavnc # Password setup (optional if using -nopw)
        run: |
          # echo "Setting up dummy VNC password file (needed by some x11vnc setups)..."
          # mkdir -p ~/.vnc
          # echo "password" | vncpasswd -f > ~/.vnc/passwd # Content doesn't matter if using -nopw
          # chmod 600 ~/.vnc/passwd

          echo "Starting x11vnc server..."
          x11vnc -display $DISPLAY \
                 -forever \
                 -shared \
                 -nopw \
                 -rfbport 5900 & # Standard VNC port, no password required
          sleep 3 # Give VNC a moment to bind to the port

      # --- CORRECTED STEP ---
      # Removed the 'with:' block as no inputs are being passed
      - name: Provide Remote Access via tmate
        id: tmate
        uses: mxschmitt/action-tmate@v3
        timeout-minutes: 350 # Keep session open (adjust as needed, max usually 360 total job time)
        # No 'with:' block needed here if using defaults and not limiting access with SSH keys

      - name: Echo Connection Instructions After tmate Starts
        # Only run this step if the tmate action successfully output connection details
        if: steps.tmate.outputs.tmateSSHCommand != ''
        run: |
          echo "----------------------------------------------------------------------"
          echo "--- Remote Session Instructions ---"
          echo ""
          echo "1. Connect to the runner via SSH using the tmate command below:"
          echo "   ${{ steps.tmate.outputs.tmateSSHCommand }}"
          echo "   (Copy and paste the above line into your local terminal)"
          echo ""
          echo "2. Once connected via SSH, the VNC server IS ALREADY RUNNING inside the runner."
          echo "   You DO NOT need to start VNC manually in the SSH session."
          echo ""
          echo "3. On YOUR LOCAL machine (not in the SSH session), start a VNC client"
          echo "   (e.g., RealVNC Viewer, TightVNC Viewer, TigerVNC, macOS Screen Sharing)."
          echo ""
          echo "4. In your VNC client, connect to the address: localhost:5900"
          echo "   (tmate automatically forwards port 5900 from the runner to your local machine)"
          echo ""
          echo "5. No VNC password is required because '-nopw' was used."
          echo ""
          echo "--- The Android Emulator UI should appear in your VNC client. ---"
          echo "--- Session will remain active for approx ${{ steps.tmate.timeout-minutes }} minutes or until job timeout ---"
          echo "----------------------------------------------------------------------"

      # Optional Keepalive - uncomment if you face issues with premature job ending despite tmate
      # - name: Keep Workflow Alive (if tmate running)
      #   if: steps.tmate.outputs.tmateSSHCommand != ''
      #   run: |
      #     echo "Keeping workflow alive while tmate session is active (checking every 60s)..."
      #     while (timeout 60s ss -lnp | grep -q ":${{ steps.tmate.outputs.tmateSshPort }} "); do # Check if tmate's SSH port is listening
      #       echo "tmate session detected, sleeping..."
      #       sleep 60
      #     done
      #     echo "tmate session appears to have ended."
