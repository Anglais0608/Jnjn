name: Android Emulator with UI & Remote Access

on:
  workflow_dispatch: # Allows manual triggering

jobs:
  emulate-and-connect:
    runs-on: ubuntu-latest
    # Increase timeout if needed (default is 360 minutes / 6 hours)
    # timeout-minutes: 60 

    steps:
      - name: Checkout code (optional)
        uses: actions/checkout@v4

      - name: Check KVM availability & Enable
        run: |
          echo "Checking KVM..."
          sudo apt-get update -y
          sudo apt-get install -y cpu-checker qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils
          sudo kvm-ok
          echo "Adding user to kvm group..."
          sudo adduser $USER kvm
          # Note: In some environments, a logout/login or reboot might be needed
          # for group changes to take effect, but it usually works in GH Actions runners.
          echo "KVM setup potentially complete."

      - name: Install Dependencies
        run: |
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends \
            openjdk-17-jdk \
            wget \
            unzip \
            xvfb \
            x11vnc \
            adb \
            tmate
          # Clean up apt cache
          sudo rm -rf /var/lib/apt/lists/*

      - name: Set up Android SDK
        env:
          # --- Customize These ---
          API_LEVEL: 30         # e.g., 30 (Android 11), 31 (Android 12), 33 (Android 13)
          TARGET: google_apis   # google_apis includes Google Play services
          ARCH: x86_64          # x86_64 is usually fastest in emulation
          AVD_NAME: test_avd
          # --- --- ----------- ---
          CMDLINE_TOOLS_VERSION: "11076708" # Check for latest: https://developer.android.com/studio#command-tools
        run: |
          echo "Setting up environment variables..."
          echo "ANDROID_SDK_ROOT=${HOME}/android-sdk" >> $GITHUB_ENV
          echo "${HOME}/android-sdk/cmdline-tools/latest/bin" >> $GITHUB_PATH
          echo "${HOME}/android-sdk/platform-tools" >> $GITHUB_PATH
          echo "${HOME}/android-sdk/emulator" >> $GITHUB_PATH
          export ANDROID_SDK_ROOT="${HOME}/android-sdk"
          export PATH="$PATH:${ANDROID_SDK_ROOT}/cmdline-tools/latest/bin:${ANDROID_SDK_ROOT}/platform-tools:${ANDROID_SDK_ROOT}/emulator"

          echo "Downloading Android Command-line tools..."
          CMDLINE_TOOLS_URL="https://dl.google.com/android/repository/commandlinetools-linux-${CMDLINE_TOOLS_VERSION}_latest.zip"
          mkdir -p "${ANDROID_SDK_ROOT}/cmdline-tools"
          wget -q "${CMDLINE_TOOLS_URL}" -O /tmp/cmdline-tools.zip
          unzip -q /tmp/cmdline-tools.zip -d "${ANDROID_SDK_ROOT}/cmdline-tools"
          # The tools unzip into a 'cmdline-tools' dir, we want them in 'latest'
          mv "${ANDROID_SDK_ROOT}/cmdline-tools/cmdline-tools" "${ANDROID_SDK_ROOT}/cmdline-tools/latest"
          rm /tmp/cmdline-tools.zip

          echo "Accepting licenses..."
          yes | sdkmanager --licenses > /dev/null || true # Ignore errors from already accepted licenses
          # Accept licenses for packages that might not be installed yet
          yes | sdkmanager --licenses --sdk_root="$ANDROID_SDK_ROOT" > /dev/null || true

          echo "Installing SDK packages..."
          sdkmanager "platform-tools" "emulator" "system-images;android-${API_LEVEL};${TARGET};${ARCH}"

          echo "Creating AVD..."
          # Using a default device profile like pixel_5 might give better compatibility
          echo "no" | avdmanager create avd -n "${AVD_NAME}" -k "system-images;android-${API_LEVEL};${TARGET};${ARCH}" --device "pixel_5" --force

          echo "AVD details:"
          avdmanager list avd

      - name: Start Virtual Display (Xvfb)
        run: |
          echo "Starting Xvfb..."
          Xvfb :99 -screen 0 1280x800x24 &
          echo "DISPLAY=:99" >> $GITHUB_ENV
          sleep 2 # Give Xvfb a moment to start

      - name: Start Android Emulator
        env:
          AVD_NAME: test_avd # Must match the name used in setup step
          DISPLAY: :99       # Must match Xvfb display
        run: |
          echo "Starting emulator..."
          # Use software rendering (swiftshader_indirect) for reliability in CI
          # KVM will still accelerate the CPU execution if enabled correctly
          emulator -avd "${AVD_NAME}" \
                   -no-snapshot \
                   -no-boot-anim \
                   -no-audio \
                   -gpu swiftshader_indirect &

          echo "Waiting for ADB device..."
          adb wait-for-device

          echo "Waiting for emulator to fully boot..."
          adb shell 'while [[ -z $(getprop sys.boot_completed) ]]; do sleep 5; echo "Waiting for boot..."; done'
          adb shell input keyevent 82 # Unlock screen

          echo "Emulator is ready."
          adb devices

      - name: Setup VNC Server
        env:
          DISPLAY: :99 # Must match Xvfb display
          VNC_PASSWORD: ghavnc # WARNING: Insecure. Use secrets for sensitive cases.
        run: |
          echo "Setting up VNC password..."
          mkdir -p ~/.vnc
          echo "$VNC_PASSWORD" | vncpasswd -f > ~/.vnc/passwd
          chmod 600 ~/.vnc/passwd

          echo "Starting x11vnc server..."
          x11vnc -display $DISPLAY \
                 -forever \
                 -shared \
                 -nopw # Using -nopw for simplicity with tmate port forwarding. 
                       # If connecting directly (not usually possible in Actions), use:
                       # -passwdfile ~/.vnc/passwd \
                 -rfbport 5900 & # Standard VNC port
          sleep 2 # Give VNC a moment

      - name: Provide Remote Access via tmate
        id: tmate
        uses: mxschmitt/action-tmate@v3
        timeout-minutes: 350 # Keep session open for a while, adjust as needed (max usually 360 total)
        with:
          # Optional: Limit access by providing public SSH keys
          # github-token: ${{ secrets.GITHUB_TOKEN }} # To authorize adding keys from specific users/teams
          # authorized-keys: |
          #   ssh-rsa AAAAB3NzaC1yc2... user@example.com

      - name: Echo Connection Instructions After tmate Starts
        if: steps.tmate.outputs.tmateSSHCommand # Only run if tmate started
        run: |
          echo "----------------------------------------------------------------------"
          echo "--- Remote Session Instructions ---"
          echo ""
          echo "1. Connect to the runner via SSH using the tmate link above."
          echo "   (It will look like: ssh <SESSION_ID>@<REGION>.tmate.io)"
          echo ""
          echo "2. Once connected via SSH, the VNC server IS ALREADY RUNNING inside the runner."
          echo "   You DO NOT need to start VNC manually in the SSH session."
          echo ""
          echo "3. On YOUR LOCAL machine (not in the SSH session), start a VNC client"
          echo "   (e.g., RealVNC Viewer, TightVNC Viewer, macOS Screen Sharing)."
          echo ""
          echo "4. In your VNC client, connect to: localhost:5900"
          echo "   (tmate forwards port 5900 from the runner to your local machine)"
          echo ""
          # If using -passwdfile:
          # echo "5. When prompted for a password, use: ghavnc" 
          # If using -nopw:
          echo "5. No VNC password is required with the current configuration."
          echo ""
          echo "--- The Android Emulator UI should appear in your VNC client. ---"
          echo "----------------------------------------------------------------------"

      # Keepalive loop - helps prevent premature termination if tmate connection drops unexpectedly
      # Might not be strictly necessary with action-tmate, but can sometimes help.
      # - name: Keep Workflow Alive (if tmate running)
      #   if: steps.tmate.outputs.tmateSSHCommand
      #   run: |
      #     echo "Keeping workflow alive while tmate session is active..."
      #     while (ss -lnp | grep -q "${{ steps.tmate.outputs.tmateSshPort }}"); do
      #       sleep 60
      #     done
      #     echo "tmate session appears to have ended."
